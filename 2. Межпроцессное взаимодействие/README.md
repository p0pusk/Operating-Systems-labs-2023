# Межпроцессное взаимодействие

Ядро предоставляет механизы доступа и синхронизации (IPC) для взаимодействия процессов. Средства IPC включают в себя 
сигналы, именованные и неименованные каналы, сообщения, сокеты, семафоры и разделяемую память. Все эти средства, кроме 
семафоров, являются локальными.

## Типы взаимодействия по доступу к данным
- передача данных
- совместное использование данных
- сигнализирование о событиии

## Типы взаимодействия по отношению процессов
- между связанными процессами (родитель и дочерний процесс)
- между несвязанными процессами

Для взаимодействия несвязанных процессов подходят сигналы, именованные каналы, очереди сообщений и разделяемая память. Неименованные каналы могут обеспечивать взаимодействие только связанных процессов.

## Сигналы
Сигналы используются для уведомления процесса об асинхронном событии или для обработки исключительной ситуации. Это 
простейший вид взаимодействия, позволяющий синхронизировать процессы или передать простейшие команды от одного процесса 
другому. Базовый перечень сигналов практически любой POSIX системы содержит не более 32 сигналов, наряду с ними часто 
системой поддерживается создание собственного уникального набора сигналов.

Команда `kill -l` выведет перечень сигналов системы

Отправить сигнал другому процессу можно системной функцией kill: `int kill(pid_t pid, int sig);`
Процесс, не обладающий правами суперпользователя, может отправлять сигналы только процессам с теми же реальным и 
эффективным идетификаторами. 

Задать поведение процесса при получении сигнала можно через установку диспозиции 
`void (*signal (int sig,  void (*disp)(int)))(int);`. Более гибкое управление реакцией на сигналы осуществляется 
функцией sigaction(): `intsigaction(int sig, const struct sigaction* act, struct sigaction* oact);`

## Неименованные каналы
Средство связи между двумя и более связанными процессами. Один процесс при данном механизме взаимодействия записывает данные в канал, а другой процесс читает. Создать канал для односторонней связи можно вызовом 

`int pipe(int pipedes[2]);`

при котором создаются два дескриптора - для чтения и для записи. Дескриптор для чтения хранится в `pipedes[0]`, для записи - в `pipedes[1]`. Файл для записи и чтения автоматически открывается при вызове `pipe`, далее читать из него и писать в него можно вызовами `ssize_t read(int fd, void* buf, size_t count)` и `ssize_t write(int fd, void* buf, size_t count)` соответственно. 

Чтобы реализовать двустороннюю связь с помощью неименованных каналов необходимо использовать два канала: в один будет писать дочерний процесс, а читать родительский; а в другой будет писать родительский процесс, а читать дочерний. 

## Именованные каналы
Могут использоваться для взаимодействия двух и более несвязанных процессов. Для создания именованного канала используется системный вызов 

`int mknod(const char *pathname, mode_t mode, dev_t dev);`

который создаст в системе специальный файл по пути `pathname`: обычный файл, файл устройства или FIFO в зависимости от аргументов. Чтобы в другом процессе открыть канал для чтения или записи, используем системный вызов `open`.
Также для создания именнованого канала можно использовать системный вызов:

`int mkfifo(const char *pathname, mode_t mode)`

Именнованные каналы поддерживают двунаправленную связь, поэтому для двустороннего общения не нужно создавать второй канал.

## Разделяемая память
Каждый процесс имеет свое адресное пространство. Для обмена информацией из адресного пространства с другими процессами необходимо использовать средства IPC. Для использования общей памяти необходимо аллоцировать сегмент общей памяти системным вызовом 

`int shmget(key_t key, size_t size, int shmflg);`

где первым аргументом передается ключ, вторым аргументом - размер сегмента разделяемой памяти, а третьим - флаги общей памяти с установленными разрешениями. Данный вызов в случае успеха возвращает идентификатор совместно используемой памяти связанный с переданным ключом. Чтобы получить идентификатор одного и того же сегмента в разных процессах необходимо передавать один и тот же ключ (кроме ключа `IPC_PRIVATE`). Далее необходимо к адресному пространству процесса присоединить созданный сегмент разделяемой памяти с помощью системного вызова

`void * shmat(int shmid, const void *shmaddr, int shmflg)`

первым аргументом которого является идентификатор общей памяти, вторым аргументом - адрес присоединения сегмента памяти, третьим - параметры присоединения общей памяти. Для управления разделяемой памятью используется вызов: 
 
 `int shmctl(int shmid, int cmd, struct shmid_ds *buf)`

 передав идентификатор сегмента разделяемой памяти, команду для выполнения операции и указатель на структуру разделяемой памяти, которая будет использоваться при выполнении операции. Допустимые значения второго аргумента - `IPC_STAT`, `IPC_SET`, `IPC_RMID`, `IPC_INFO`, `SHM_INFO`. В случае успеха в зависимости от значения `cmd` возвращается индекс или идентификатор сегмента разделяемой памяти или 0.
 
После окончания использования необходимо отсоединить сегмент общей памяти от адресного пространства процесса вызовом 

`int shmdt(const void *shmaddr)`

## Очереди сообщений
Данный тип взаимодействия хорошо подходит для обмена небольшим объемом информации, когда необходимо использовать эту информацию только одним процессом разово и учитывая очередность. Для использования очереди сообщений необходимо создать ее по ключу или получить идентификатор уже существующей очереди сообщений вызовом 

`int msgget(key_t key, int msgflg)`

По первому аргументу определяется идентификатор очереди сообщений, второй аргумент служит для установки параметров очереди, в том числе прав доступа. Поместить сообщение в очередь можно системным вызовом

`int msgsnd(int msgid, const void *msgp, size_t msgsz, int msgflg)`

Первый аргумент - идентификатор очереди сообщений, второй аргумент является указателем структуру общего вида 
```
struct msgbuf {
   long mtype;      /* message type, must be > 0 */
   char mtext[1];   /* message data */
};
```
Поле `mtext` - массив или другая структура, размер которой передается в вызов параметром `msgsz`. Последний аргумент позволяет настроить параметры отправки сообщения. Чтобы извлечь сообщение из очереди по идентификатору используется вызов

`int msgrcv(int msgid, const void *msgp, size_t msgsz, long msgtype, int msgflg)`

Здесь `msgp` также является структурой `msgbuf`, а `msgsz` размером поля `mtext` этой структуры. Аргумент 4 указывает тип сообщения, а аргумент 5 позволяет настроить параметры извлечения сообщения. Очереди сообщений поддерживают выполнение операций управления аналогично разделяемой памяти вызовом:

`int msgctl(int msgid, int cmd, struct msqid_ds *buf)`

## Отображение памяти
Метод взаимодействия при котором создается отображение в виртуальном адресном пространстве. Файлы или устройства отображаются в память процесса. Также возможно анонимное отображение, когда отображается область виртуальной памяти процесса без поддержки файла, оно похоже на выделение памяти на куче. Тип отображения может быть частным (`MAP_PRIVATE`) или общим (`MAP_SHARED`) и определяет видимость изменений содержимого отображения. Для получения начального адреса отображения используется вызов:

`void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`

Первый аргумент - виртуальный адрес, пользователь может передать нулевой указатель и тогда система сгенерирует виртуальный адрес. Вторым аргументом передается длина сопоставляемого сегмента памяти. Аргумент `prot` указывает желаемую степень защиты памяти, аргумент `flags` определяет тип отображения по видимости изменений и позволяет задать другие параметры. Содержание отображения определяется длиной `length`, отступом `offset` в файле или другом объекте, определяемом файловым дескриптором `fd`.

Для удаления отображения определенной длины используется системный вызов:

`int munmap(void *addr, size_t length);`

## Сокеты
Создать узел связи для взаимодействия и получить файловый дескриптор для этого узла можно системным вызовом:

`int socket(int domain, int type, int protocol);`

Первый аргумент определяет область коммуникации (локальная коммуникация, IPv4 Internet протокол и другие). Сокет имеет тип, который задается вторым аргументом и определяет семантику общения (`SOCK_STREAM`, ...) и может дополнительно задавать определенное поведение сокета (`SOCK_NONBLOCK`, ...). Аргумент `protocol` определяет конкретный протокол, который будет использоваться в сокете. Вызов возвращает дескриптор созданного сокета. Для назначения сокету адреса из адресного пространства используется системный вызов

`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`

В котором передается дескриптор сокета и адрес, который будет привязан к сокету, и размер участка памяти. Для прослушивания сокета используется вызов

`int listen(int sockfd, int backlog);`

Аргументами являются дескриптор сокета и максимальное число подключений, которые возможно хранить в очереди для данного сокета. Чтобы принять запрос на присоединение после вызова `listen` используется системный вызов 

`int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`

в который передается указатель на структуру хранящую адрес протокола клиента и размер данной структуры. По завершении вызова вернется файловый дескриптор принятого сокета. Клиент для подключения к серверу, который прослушивает сокет  может использовать вызов:

`int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`
