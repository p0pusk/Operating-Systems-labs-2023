 # Межпроцессное взаимодействие в системе linux
 
## Общее описание
В каждом варианте лабораторной работы требуется написать одну или две программы на языке С++, которые выполняют 
требуемые действия с помощью нескольких видов межпроцессного взаимодействия в системе Linux. Файлы работы должны собираться с помощью Makefile. Программы 
должны корректно обрабатывать ошибки и выводить соответствующие сообщения (рекомендуется вывод в лог), кроме того, 
в логе должны выводиться статусные сообщения (присоединился, завершился, включился и тп).

## Типы процессов
В результате в каждом варианте может получиться один или два процесса/программы двух видов:
- Хост. Есть в любом варианте. Является инициатором (процессом/программой, которая создает все виды взаимодействия, 
семафоры и т.д.). Запускается всегда первым. Файл с функцией main хоста должен называться host.cpp
- Клиент. В некоторых вариантах присутствует в виде ребенка хоста, в других — отдельным независимым 
процессом/программой. Если является отдельной программой, файл с функцией main должен называться client.cpp

## Дополнительные операции
### Знакомство(handshake) 
Производится перед установкой соединения, используется для синхронизации идентификаторов соединения. Типы: 
- Без знакомства. Никаких дополнительных действий не производится
- Знакомство с помощью сигналов. Клиенту при запуске передается pid хоста, на этот pid клиент отправляет сигнал SIGUSR1.
- Двустороннее знакомство с помощью сигнала. Данный тип используется в случае, когда на момент соединения клиента, 
канал для связи ещё не создан и хост должен оповестить клиента о факте этого создания. Данного оповещения клиент 
синхронно ожидает после отправки своего первого сообщения хосту. Кроме того, в ответе от хоста (можно обойтись и без 
этого) передаётся id клиента в сессии, с помощью которого клиент получает нужные идентификаторы дескрипторов для связи. 
Например, первый клиент получает id 1 и открывает файл pong_fifo1, второй - pong_fifo2 и тд.

### Синхронизация 
Используется для установки очередности операций записи/чтения в соединении. Типы: 
- Локальные семафоры. sem_init.
- Глобальные семафоры. sem_open.

Все запросы на ожидание в семафорах и функциях ожидания сигнала (за исключением случаев запланированного ожидания, 
например, при ожидании ввода от пользователя) должны иметь тайм-ауты 5 секунд, в случае превышения таймаута связь 
должна прерываться, а клиент — останавливать работу.

## Типы и виды конфигураций
В работе могут быть реализованы различные виды отношений хост-клиент(-ы), а так же два типа, реализация которых зависит 
от вида. Виды конфигурации:
- “Родственные”. Клиенты являются процессами-потомками хоста, порожденными функцией fork. Используется первый вид 
знакомства (“Без знакомства”). Типы:
  - Один к одному. Каждый хост запускает ровно одного клиента. Синхронизация локальным семафором
  - Один ко многим. Каждый хост запускает (в теории) неограниченное количество клиентов. Для работы с каждым клиентом 
  выделяется отдельный поток.
- “Независимые”. Клиенты являются независимыми процессами, при запуске им передается pid хоста. Здесь необходимо 
использовать содержательные типы знакомства. Типы:
  - Один к одному. Каждый хост работает ровно с одним клиентом. Синхронизация глобальным семафором. Знакомство: 
  знакомство с помощью сигнала.
  - Один ко многим. Каждый хост работает (в теории) с неограниченным количеством клиентов. Для работы с каждым клиентом 
  выделяется отдельный поток. Синхронизация с помощью глобального семафора. Знакомство: двустороннее знакомство с 
  помощью сигнала.

## Требования к исходным файлам и CMakeLists
1. Различные типы взаимодействия должны быть реализованы в различных файлах с префиксом “conn_”, за которым следует 
кодовое название типа взаимодействия. Исходный код каждого типа должен быть вынесен в класс, все классы должны иметь 
одинаковый интерфейс. Пример интерфейса:
``` cpp
 class Conn
{
public:
Conn(SomeType id , bool create);
void/bool Read(void *buf, size_t count);
void/bool Write(void *buf, size_t count);
~Conn();
}
```
2. Каждый файл с расширением *.cpp (*.c,..) должен автоматически компилироваться в объектный файл без изменения 
CMakeLists
3. Код функции main хоста и клиента (в случае независимой конфигурации) должен находиться в файлах host.cpp и 
client.cpp соответственно
4. Файлы должны компилироваться с флагами -Wall и –Werror
5. Для каждого исходного файла (*.cpp/*.c) с префиксом “conn_*”, автоматически должны генерироваться исполняемые файлы 
“host_*” и “client_*” (в случае независимой конфигурации), где * - кодовое слово типа взаимодействия (TYPE_CODE)
6. Вызов команды make в папке проекта должен приводить к тому, что будут собраны все исполняемые файлы host* и client* 
для всех видов взаимодействия, реализованных в файлах “conn_*”
7. Необходимо завернуть вызов cmake в скрипт build.sh. Данный скрипт должен очищать все промежуточные файлы, 
сгенерированные cmake-ом

## Типы взаимодействия
В случае реализации родственной конфигурации необходимо использовать специальные модификации типов, предназначенные для 
использования родственными процессами, если таковые предусмотрены во всех перечисленных в варианте видах
1. Общая память (mmap). TYPE_CODE - mmap. Anonymous mapping.
2. Общая память (shmget). TYPE_CODE - seg. Заполнение родительским процессом данных в сегмент должно происходить уже 
после создания дочернего процесса.
3. Общие файлы (shmopen+mmap). TYPE_CODE - shm. Здесь, в отличие от пункта 1, работа с общей памятью должна 
производиться в каждом процессе уже после создания дочернего (так, будто это несвязанные процессы).
4. Очереди сообщений (mq_open). TYPE_CODE - mq. Работа с очередью должна производиться в каждом процессе уже после 
создания дочернего (так, будто это несвязанные процессы).
5. Программные каналы (pipe). TYPE_CODE - pipe.
6. Именованные каналы (mkfifo). TYPE_CODE - fifo. Работа с именованным каналом должна производиться в каждом процессе 
уже после создания дочернего (так, будто это несвязанные процессы). После окончания работы родительский процесс должен 
удалять файл именованного канала.
7. Сокеты (socket). TYPE_CODE – sock

## Варианты заданий
### Описание основных сценариев
1. Тематическая пошаговая игра “Волк и семеро козлят”. Хост - волк, клиент(ы) - козлята, n- количество козлят. На каждом 
ходу волк выбрасывает число от 1 до 100 (у пользователя есть возможность вводить число в приложении самостоятельно; 
если на протяжении 3 сек. число не было введено, оно выбирается случайно), живые козлята выбрасывают число от 1 до
100 случайным образом, а мертвые - число от 1 до 50. Если число живого козленка отличается от числа волка не более, 
чем на 70/n, то считается, что он спрятался. Козлята, которые не спрятались, попадаются и считаются мертвыми. Если 
число, полученное мертвым козленком, отличается не более, чем на 20/n - он воскресает. До подключения козлят ничего не 
происходит, игра заканчивается, если в течение 2 ходов подряд все козлята мертвы. За логику отвечает хост, прогресс 
игры отображается в его выводе в консоль, клиенты шлют ему числа козлят, а в ответ получают статус козленка 
(жив, мертв). В каждом раунде нужно выводить числа, выбрасываемые волком и козлятами и число спрятавшихся, попавшихся 
и мертвых козлят.
2. Локальный сетевой чат. Хост и клиенты - участники чата. Хост может как сам отправлять личные и общие сообщения в чат,
так и передавать сообщения от других участников в общий чат или лично. Общие сообщения отображаются в чате (консоли) у всех 
подключенных участников, личные сообщения отображаются в чате только у отправителя и адресата. Если клиент не отправляет
сообщения больше минуты и не является хостом, то ему отправляется SIGKILL для завершения. Сообщения в чате появляются в
порядке времени их отправления.

### Варианты
  Номер | Сценарий | Конфигурация                 | Типы взаимодействия | Баллы |
|:------|:---------|:-----------------------------|:--------------------|:------|
| 1     | 1        | Родственные. Один к одному.  | 1, 3, 5             | 10    |
| 2     | 1        | Родственные. Один к одному.  | 2, 4, 6             | 10    |
| 3     | 1        | Родственные. Один к одному.  | 4, 6, 7             | 15    |
| 4     | 1        | Независимые. Один к одному.  | 1, 3, 6             | 10    |
| 5     | 1        | Независимые. Один к одному.  | 2, 4, 6             | 15    |
| 6     | 1        | Независимые. Один к одному.  | 4, 6, 7             | 15    |
| 7     | 1        | Родственные. Один ко многим. | 3, 4, 5             | 15    |
| 8     | 1        | Родственные. Один ко многим. | 5, 6, 7             | 15    |
| 9     | 1        | Независимые. Один ко многим. | 3, 4, 6             | 15    |
| 10    | 1        | Независимые. Один ко многим. | 4, 6, 7             | 20    |
| 11    | 2        | Родственные. Один к одному.  | 1, 3, 5             | 10    |
| 12    | 2        | Родственные. Один к одному.  | 2, 4, 6             | 10    |
| 13    | 2        | Родственные. Один к одному.  | 4, 6, 7             | 15    |
| 14    | 2        | Независимые. Один к одному.  | 1, 3, 6             | 10    |
| 15    | 2        | Независимые. Один к одному.  | 2, 4, 6             | 15    |
| 16    | 2        | Независимые. Один к одному.  | 4, 6, 7             | 15    |
| 17    | 2        | Родственные. Один ко многим. | 3, 4, 5             | 15    |
| 18    | 2        | Родственные. Один ко многим. | 5, 6, 7             | 15    |
| 19    | 2        | Независимые. Один ко многим. | 3, 4, 6             | 15    |
| 20    | 2        | Независимые. Один ко многим. | 4, 6, 7             | 20    |

Возможна реализация не всех типов взаимодействия. Баллы за нереализованный вид взаимодействия будут выставляться 
следующим образом:

 Число нереализованных взаимодействий / базовый балл| 10 | 15 | 20  |
|:-------------------------------------------------|:---|:---|:----|
| 1                                                | 7 | 10 | 13  |
| 2                                                | 3 | 5  | 7   | 